<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Alexandria Case Study</title><link>https://alexandria-reader.github.io/</link><description>Recent content on Alexandria Case Study</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://alexandria-reader.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Competitor Analysis</title><link>https://alexandria-reader.github.io/competitors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/competitors/</guid><description>Why is language acquisition so evasive for the majority of language learners? Why has decades of grammar rules, repetition drills, and computer-assisted learning shown only limited success? In recent years, research surrounding both second language acquisition as well as literacy has shown that language acquisition occurs when we comprehend messages alongside its surrounding context [1]. More specifically, the &amp;ldquo;input hypothesis&amp;rdquo; states that we acquire language in one way and one way only: when we understand messages, and when we obtain comprehensive input.</description></item><item><title>Technical decisions</title><link>https://alexandria-reader.github.io/decisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/decisions/</guid><description>TypeScript vs JavaScript Before we started developing Alexandria, none of us had any real experience using TypeScript, whereas we all had a solid foundation in JavaScript. Yet after doing a lot of research, we decided to use TypeScript in our project. Why?
Static typing One of the main reasons is the static typing that is a core part of TypeScript. In JavaScript, an object can have whatever properties you want, and you can add and remove them as you see fit.</description></item><item><title>Database and API</title><link>https://alexandria-reader.github.io/database-api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/database-api/</guid><description>With the technical decisions settled, it was time to design two vital aspects of the backend architecture: the database and the API.
While a database of some form would always have been necessary, exposing an API was the result of going with a single page React app that talks to the server via API calls. This also opens the door for alternative front ends at a later stage - a mobile app could use the same back end.</description></item><item><title>Challenges and Solutions</title><link>https://alexandria-reader.github.io/challenges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/challenges/</guid><description>While the designing database and API were challenging in and by themselves, and the thorough preparation definitely paid of during the coding stage, there were, of course, still hurdles to overcome, problems to solve, solutions to find.
Finding the user&amp;rsquo;s words and phrases in the text We have already discussed why we chose to work with a relational database as opposed to a document-based one. But our decision to use PostgreSQL brought another benefit with it, and that is the build in full text search which we put to good use to solve.</description></item><item><title>MVP and Future Plans</title><link>https://alexandria-reader.github.io/future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/future/</guid><description>MVP Confronted with the fully-fledged feature set of commercial language learning applications, our team made the early decision to create a minimum viable product that reflects the essence of what we find crucial in such a product.
User experience: mobile-first, fast and seamless processing of user interactions Backend and API: layered, robust, RESTful, maintainable, and flexible enough to service front-end needs Database: normalized and withstands scale CI/CD: establish continuous deployment pipelines Moving Forward Our core team has plans to continue support the maintenance and development of Alexandria.</description></item><item><title>Meet the Team</title><link>https://alexandria-reader.github.io/team/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/team/</guid><description>Dana Chen Eamon O&amp;rsquo;Callaghan Marc Hermann</description></item><item><title>References</title><link>https://alexandria-reader.github.io/references/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/references/</guid><description> Stephen Krishan (2021): Explorations in Language Acquisition and Use Yaroslav Lapin (2021) : Jotai vs. Recoil: What are the differences? Edgar F. Codd (1972): Further Normalization of the Data Base Relational Model Roy Fielding (2000): Architectural Styles and the Design of Network-based Software Architectures</description></item></channel></rss>