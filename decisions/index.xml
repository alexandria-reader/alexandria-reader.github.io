<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Technical Decisions on Alexandria Case Study</title><link>https://alexandria-reader.github.io/decisions/</link><description>Recent content in Technical Decisions on Alexandria Case Study</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://alexandria-reader.github.io/decisions/index.xml" rel="self" type="application/rss+xml"/><item><title>Choosing TypeScript</title><link>https://alexandria-reader.github.io/decisions/typescript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/decisions/typescript/</guid><description>Since its inception, TypeScript has been touted as a supercharged version of JavaScript that has the ability to spot common errors through a typed system, making the application more robust throughout its development.
Prior to developing Alexandria, we looked into TypeScript as a feasible substitute to JavaScript.
Static typing JavaScript is dynamically typed. Therefore, it is not aware of variable type before instantiation at run time. TypeScript, on the other hand, is statically typed.</description></item><item><title>SQL or NoSQL?</title><link>https://alexandria-reader.github.io/decisions/sql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/decisions/sql/</guid><description>Alexandria is primarily deployed as a web application, where users log in and interact with the information they have stored on the platform. Therefore, robust and scalable database choice is a must.
Our research comparing between SQL and NoSQL databases centred around the following issues.
Parameter SQL NoSQL Ability to handle high volume of complex queries ✅ ❌ Scalability Vertical Horizontal Data type Structured Unstructured SQL Structured Query Language (SQL) is the standard language for dealing with relational databases that define relationships in the form of tables.</description></item><item><title>3 Layers for the Back End</title><link>https://alexandria-reader.github.io/decisions/backend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/decisions/backend/</guid><description>Alexandria is built based on the principles of service-oriented architecture [2]. In order to achieve readability, testability, and maintainability, we ensured a separation of concerns when it came to implementing the back end.
More specifically, we designed the back-end server in three layers.
Input layer Logic Layer Data Access Layer Responsible for accepting HTTP requests, authentication, validating format, dispatch to correct logic function Algorithm operates on the data in response to user input Reading and writing in-memory representation of records to and from database, performing complex queries over data Based on this three-layer design including routes, services layer and data access layer, business logic is extracted away from the API.</description></item><item><title>React and Recoil</title><link>https://alexandria-reader.github.io/decisions/react-recoil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alexandria-reader.github.io/decisions/react-recoil/</guid><description>Project requirements In order to achieve both performance and user experience objectives for Alexandria, we settled on a number of goals to fullfil at the initial stages.
One of the key features of the app is to reflect the changes made by a particular user interaction immediately, without an additional page reload.
Consider the following user actions and their effects on a piece of text. Our challenge is to make every user interaction feel instantaneous and seamless.</description></item></channel></rss>