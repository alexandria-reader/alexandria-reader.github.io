<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us>
<head>
<meta name=generator content="Hugo 0.91.2">
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<title>Alexandria - Design Notes</title>
<link rel="shortcut icon" href=favicon.ico type=image/x-icon>
<link href="https://fonts.googleapis.com/css?family=Dosis:wght@200;300;400;500;600;700;800&display=swap" rel=stylesheet>
<link rel=stylesheet href=/css/styles.css>
<link href=/index.xml rel=alternate type=application/rss+xml title=Alexandria>
</head>
<body>
<div class="sidebar sidebar-grey">
<div class=navigation>
<div>
<img src=/images/logo-light.png alt="Alexandria logo">
<p style=font-size:smaller;font-family:Dosis>Learn languages by translating texts</p>
</div>
<h1 class=site-title><a href=/>Alexandria</a></h1>
<nav class=internal>
<ul>
<li>
<a href=#introduction>Introduction</a>
</li>
<li>
<a href=#decisions>Technical decisions</a>
</li>
<li>
<a href=#database-api>Database and API design</a>
</li>
<li>
<a href=#challenges>Challenges and Solutions</a>
</li>
<li>
<a href=#future>Current State and Future Plans</a>
</li>
<li>
<a href=#team>Team</a>
</li>
<li>
<a href=#references>References</a>
</li>
</ul>
</nav>
<nav class=external>
<div class=external-title>Check out Alexandria:</div>
<ul id=shortcuts>
<li>
<a href=https://tryalexandria.com target=_blank rel=noopener>Use the app, learn a language</a>
</li>
<li>
<a href=https://github.com/alexandria-reader/ target=_blank rel=noopener>Visit Alexandria on Github</a>
</li>
</ul>
</nav>
</div>
</div>
<div class=content>
<section class=page id=introduction>
<h1>
<a href=#introduction>Introduction</a>
</h1>
<div class=content>
<p>Why is language acquisition so evasive for the majority of language learners? Why has decades of grammar rules, repetition drills, and computer-assisted learning shown only limited success? In recent years, research surrounding both second language acquisition as well as literacy has shown that language acquisition occurs when we comprehend messages alongside its surrounding context 1. More specifically, the &ldquo;input hypothesis&rdquo; states that we acquire language in one way and one way only: when we understand messages, and when we obtain comprehensive input.</p>
<p>With this very specific language learning need in mind, a number of web applications has been created in recent years. Language learning enthusiasts have embraced those platforms to supplment their language learning journey.</p>
<p>Despite a choice of platforms that range from open source software to paid software, there are shortcomings. The language learning enthusiast in our team has identified a number of weaknesses that Alexandria seeks to address.</p>
<h3 id=competitor-analysis>Competitor analysis</h3>
<p>Current &ldquo;learning with text&rdquo; software applications fall under two broad groups.</p>
<p>One group includes long-standing open source projects that are well received but sparsely maintained, or newer free applications that started with a bang, but were quickly forgotten and subsequently neglected.</p>
<p>The second group of applications are commercial solutions that address the goal of language learning with text, but suffer from feature bloat, lack of user friendliness, or mobile performance issues.</p>
<p>Alexandria would like to become the go-to solution for language learning enthusiasts. Through keeping the product free and open source, we aspire to continue developmenting product features that are crucial to language learners, while maintaining a joyful user experience based on the latest technological offerings.</p>
<table>
<thead>
<tr>
<th></th>
<th>Existing Free/Open Source Software</th>
<th>Alexandria</th>
<th>Commerical Products</th>
</tr>
</thead>
<tbody>
<tr>
<td>Interactive front-end user experience</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Open Source</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Ongoing Development</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Mobile First</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Responsiveness to Community Input</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Phrase Selection</td>
<td>❌</td>
<td>✅</td>
<td>❓</td>
</tr>
</tbody>
</table>
<p>Our main objectives at the initial stage are to: create a modern, fast, open source webapp with a mobile first interface. This will allow users to quickly and easily start learning without struggles with the interface, or excessive wait times for content to load.</p>
</div>
</section>
<section class=page id=decisions>
<h1>
<a href=#decisions>Technical decisions</a>
</h1>
<div class=content>
<p>How we decided on technologies we used.</p>
<h3 id=typescript-vs-javascript>TypeScript vs JavaScript</h3>
<p>Before we started developing Alexandria, none of us had any real experience using TypeScript, whereas we all had a solid foundation in JavaScript.
Yet after doing a lot of research, we decided to use TypeScript in our project. Why?</p>
<h4 id=static-typing>Static typing</h4>
<p>One of the main reasons is the static typing that is a core part of TypeScript. In JavaScript, an object can have whatever properties you want, and you can add
and remove them as you see fit. In TypeScript, types are static, meaning that once an object&rsquo;s type is declared, it does not change its type and can
only take certain values.</p>
<p>An example of this is a <code>UserWord</code> which is how we chose to represent the words that a user saved to the database by adding a translation and status.</p>
<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#00a8c8>type</span> <span style=color:#75af00>UserWord</span> <span style=color:#f92672>=</span> <span style=color:#111>{</span>
  <span style=color:#75af00>id?</span>: <span style=color:#00a8c8>number</span><span style=color:#111>,</span>
  <span style=color:#75af00>word</span>: <span style=color:#00a8c8>string</span><span style=color:#111>,</span>
  <span style=color:#75af00>status?</span>: <span style=color:#00a8c8>Status</span><span style=color:#111>,</span>
  <span style=color:#75af00>translations</span>: <span style=color:#00a8c8>Array</span><span style=color:#111>&lt;</span><span style=color:#f92672>Translation</span><span style=color:#111>&gt;,</span>
  <span style=color:#75af00>languageId?</span>: <span style=color:#00a8c8>string</span>
<span style=color:#111>};</span>
</code></pre></div><p>The type <code>UserWord</code> has 5 properties with predefined types. So if, for example, we tried to add a <code>languageId</code> that was a number, we would immediately
be warned by the compiler that the wrong type had been added. An even better example is the <code>translations</code> property, which takes an array of <code>Translation</code> type objects. If we tried to add something to the array that was not of type <code>Translation</code>, we would again be warned by the compiler.</p>
<p>Another useful feature is that if you try to add a property that has not been declared on the type, for example <code>language</code>, the compiler would warn you that the property <code>language</code> does not exist on type <code>UserWord</code>.</p>
<p>The warnings given by the compiler and even by our IDE of choice, VSCode, were invaluable in alerting us to type-related bugs before the code was even run.
Over the course of development, this saved us a significant time and frustration as far fewer errors made it into the codebase. Even errors as simple as misspelled variables are caught by the TypeScript compiler.</p>
<h4 id=code-readability>Code readability</h4>
<p>TypeScript greatly increases the readability of our code. Let&rsquo;s take a function that takes an object as a parameter. In JavaScript, you would have to be familiar with that object and its properties, or possibly log the object to the console to see what properties exist on the object. With TypeScript in VSCode, you can simply over the mouse over the type declaration to see a list of the properties that object will have as well as the types of each of those properties.</p>
<p>This means that in future, if more developers join our project, it will be much easier for them to get up to speed on with our codebase. This also results in increased code stability, as you can be sure exactly what properties an object will have, or whether a certain variable is possibly null.</p>
<h4 id=easy-refactoring>Easy refactoring</h4>
<p>TypeScript makes refactoring much easier. For example, if you change a function&rsquo;s name, but forget to change the name in another file, the TypeScript compiler will immediately alert you to the issue, even showing you the exact file and line of code where the problem resides. This means that you can refactor with confidence, resulting in a cleaner codebase.</p>
<h4 id=future-advantages>Future advantages</h4>
<p>All of this means that as the codebase grows and more developers join the project, it will be easier for them to get up to speed, and the codebase will be more stable.</p>
<h4 id=disadvantages-of-typescript>Disadvantages of TypeScript</h4>
<p>Of course, nothing is perfect. Some of the disadvantages of TypeScript include:</p>
<p>Longer code. Using TypeScript involves writing more code than with JavaScript, meaning that writing the code can take longer than with just plain JavaScript.</p>
<p>Having to learn TypeScript. As I mentioned above, none of us had any real experience with TypeScript before beginning this project, so learning TypeScript on top of designing and coding the app resulted in longer development time, especially in the beginning stages. Thankfully, having a strong base in JavaScript made this process much easier.</p>
<p>TypeScripts static typing is not true static typing. Once TypeScript is compiled, it is transpiled into untyped Javascript, meaning that there is still a small risk of type problems at runtime.</p>
<h4 id=conclusion>Conclusion</h4>
<p>Overall, we felt that the benefits clearly outweighted the disadvantages for our usecase. It was worth putting in the extra effort of using TypeScript as it helped us catch bugs before the code was run, meaning that they didn&rsquo;t make it into production. The added readability and easy refactoring made TypeScript the clear winner.</p>
<h3 id=postgresql>PostgreSQL</h3>
<h3 id=react>React</h3>
<h4 id=project-requirements>Project requirements</h4>
<p>In order to achieve both performance and user experience objectives for Alexandria, we settled on a number of goals that we&rsquo;d like to fullfill at the initial stsage.</p>
<p>One of the key features of the app is to reflect the changes made by a particular user interaction immediately, without an additional page reload.</p>
<p>Consider the following user actions and their effects on a piece of text. Our challenge is to make every user interaction feel instantaneous and seamless.</p>
<table>
<thead>
<tr>
<th>User action</th>
<th>Immediate Rendering</th>
</tr>
</thead>
<tbody>
<tr>
<td>Click on word/phrase</td>
<td>Translation input box available</td>
</tr>
<tr>
<td>Click on highlighted word/phrase</td>
<td>Translation and status displayed</td>
</tr>
<tr>
<td>Update word/phrase status</td>
<td>Highlighted colour on word changes</td>
</tr>
</tbody>
</table>
<p>Another challenge is the ability of the UI to keep in sync with state changes of variables. With increased complexity, it becomes harder to track the exact state of the UI at every given moment during the lifecycle of the application. The challenge is to represent the UI accurately after a possible flurry of user interactions.</p>
<h4 id=plain-javascript-versus-react>Plain Javascript versus React</h4>
<p>Pitting plain JS against React against Alexandria&rsquo;s initial requirements, React was the easy winner. Below is a summary of some of the differences between the two languages as it pertains to Alexandria.</p>
<h5 id=rendering-efficiency>Rendering efficiency</h5>
<p>With Javascript, UI is created in HTML on the server side, and sent to the browser. Each user interaction resulting in a data change requires an API call to the backend, and a re-rendering of the browser based on the new DOM. We briefly considered templating engines like Handlebars. While they are excellent choices for server-side rendering, they do not meet Alexandria&rsquo;s goal of delivering speedy incremental updates of the DOM, event-handling, or frontend to backend communication.</p>
<p>On the other hand, React defines UI on the browser. An app starts with a blank container and loads the UI. The UI is defined by a component that returns the JSX - a HTML lookalike. The new component is rendered into the div contianer using the <code>ReactDOM</code> library, and the result will appear directly on the browser.</p>
<p>Because each UI is broken into smaller components, each component can render independently due to its use of the virtual DOM. One change in a component does not result in the re-rendering of the entire page, merely the changed component, thus improving the front-end user experience significantly.</p>
<h5 id=state-management>State management</h5>
<p>In JS, an event listener is attached to a DOM element to listen for changes. With each state change, we track the value deviation function, re-run the deviation functions and track the changes in return value. Those changed values are passed to the appropriate DOM element through the DOM API.</p>
<p>With React, the UI is set up to keep the entire state of a variable in the form of a &ldquo;controlled component&rdquo;, while an event (e.g. a button press) can be specified directly in the code, with no need for an event listener. The change to variable is registered, and the UI is updated automatically. There&rsquo;s no need to go into the DOM to find the variable to update.</p>
<p>Being able to design components that hold state was fundamental to the design of Alexandria. Using React, each &ldquo;word&rdquo; residing within a piece of text can have it&rsquo;s own state (translation, learning stage, context). When a user changes a word&rsquo;s state, the result is displayed immediately on the DOM. In this case, the word would be highlighted, and its translation and context would be saved to the word&rsquo;s state.</p>
<p>React&rsquo;s implementation of hooks and component state fit perfectly with this requirement.</p>
<h5 id=maintainability-and-reusability>Maintainability and Reusability</h5>
<p>In JS, the markup and functionality are kept separate. As apps grow bigger, this becomes a major source of complexity, where a developer needs to keep track of both sets of codes.</p>
<p>In React, the app is split into components, where each component maintains the code required to both display and upates the UI. This also allows reusability of components, another benefit.</p>
<h3 id=recoil>Recoil</h3>
<h3 id=heroku--netlify>Heroku + Netlify</h3>
</div>
</section>
<section class=page id=database-api>
<h1>
<a href=#database-api>Database and API design</a>
</h1>
<div class=content>
<p>With the technical decisions settled, it was time to design two vital aspects of the backend architecture: the database and the API.</p>
<p>While a database of some form would always have been necessary, exposing an API was the result of going with a single page React app that talks to the server via API calls. This also opens the door for alternative front ends at a later stage - a mobile app could use the same back end. It is also in line with Alexandria being an open source project, allowing for decoupled contributions to front end or back end.</p>
<h3 id=database-architecture>Database architecture</h3>
<p>The basic idea behind the database design was to keep the main tables small and self contained, and work with references (foreign keys) to establish connections where possible in order to normalize the database.</p>
<h4 id=normalization>Normalization</h4>
<p>To normalize a database means to organize or structure it in a way that avoids redundancy of data, undesirable dependencies, and inconsistencies.</p>
<p>In his paper &ldquo;Further Normalization of the Data Base Relational Model"
<sup><a href=#references>[2]</a></sup>, Edgar F. Codd, the &ldquo;father&rdquo; of the relational database model, listed these objectives of nomalization:</p>
<ol>
<li><em>To free the collection of relations from undesirable insertion, update and deletion dependencies.</em></li>
<li><em>To reduce the need for restructuring the collection of relations, as new types of data are introduced, and thus increase the life span of application programs.</em></li>
<li><em>To make the relational model more informative to users.</em></li>
<li><em>To make the collection of relations neutral to the query statistics, where these statistics are liable to change as time goes by.</em></li>
</ol>
<p>The following set of tables serves as an example for a database structure that is not properly normalized.</p>
<h6 id=table-1>Table 1:</h6>
<table>
<thead>
<tr>
<th>username</th>
<th>word</th>
<th>word_language</th>
<th>translation</th>
<th>translation_language</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mark</td>
<td>house</td>
<td>en</td>
<td>Haus</td>
<td>de</td>
</tr>
<tr>
<td>Dana</td>
<td>house</td>
<td>en</td>
<td>maison</td>
<td>fr</td>
</tr>
<tr>
<td>Eamon</td>
<td>casa</td>
<td>es</td>
<td>house</td>
<td>en</td>
</tr>
</tbody>
</table>
<h6 id=table-2>Table 2:</h6>
<table>
<thead>
<tr>
<th>id</th>
<th>username</th>
<th>email</th>
<th>is_admin</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>Dana</td>
<td><a href=mailto:dana@email.com>dana@email.com</a></td>
<td>true</td>
</tr>
<tr>
<td>1002</td>
<td>Eamon</td>
<td><a href=mailto:eamon@email.com>eamon@email.com</a></td>
<td>true</td>
</tr>
<tr>
<td>1003</td>
<td>Mark</td>
<td><a href=mailto:marc@email.com>marc@email.com</a></td>
<td>false</td>
</tr>
</tbody>
</table>
<p>The first table holds values of four key entities of Alexandria: <code>users</code>, <code>words</code>, <code>translations</code>, and <code>languages</code>. The second table is the <code>users</code> table to go with it.</p>
<p>There are two independent <code>username</code> columns, an example of redundancy that can lead to so-called &ldquo;update anomalies&rdquo;: It turns out that Marc is not spellt with a &ldquo;k&rdquo; but with a &ldquo;c&rdquo;. If we only change this in the <code>users</code> table, the data will become inconsistent, because it still says &ldquo;Mark&rdquo; in the first table. The username needs to be updated in two different places which is prone to errors.</p>
<h5 id=normal-forms>Normal forms</h5>
<p>Normalization of relational databases is guided by rules that build on each other. They are called &ldquo;normal forms&rdquo;.</p>
<p>To satisfy the the first normal form (<strong>1NF</strong>), data sets must not contain tables themselves, and each data set must have a unique primary key. In the example above, there are no nested tabels, but only the <code>users</code> table has a primary key (<code>id</code>), so not even 1NF is satisfied.</p>
<p>The second normal form (<strong>2NF</strong>) fulfills the rules of the first normal form, and it also demands every attribute of a dataset is functionally dependent on the primary keys. Those attributes that do not depend on the primary key should go in their own table and be linked with a foreign key instead.</p>
<p>The third normal form (<strong>3NF</strong>) adds the rule that transitive functional dependencies must be eliminated as well: If B depends on primary key A, but C depends on B, then both B and C should be extracted to their own table.</p>
<p>There are higher normal forms but they are rarely encountered in the wild. If our database were to satisfy 3NF it would be safe from insertion, update and deletion anomalies. Did we succeed with our design? Let&rsquo;s find out&mldr;</p>
<h4 id=tables-more-tables-no-sorry-fewer-tables-again>Tables. More tables! No, sorry, fewer tables again.</h4>
<p>We started out with a couple of fairly basic design. This is the graphical representation of one the first drafts:</p>
<p><img src=/images/database-design-marc-1.0.png alt></p>
<p>But as we let our imagination run wild the demand for tables and table columns grew in line with our feature list. &ldquo;Hey, wouldn&rsquo;t it be nice if the user could choose from other users' translations?&rdquo;, or &ldquo;I think every time an existing translation is applied, it should save a new context.&rdquo;, or &ldquo;Will users be able to set a preferred web dictionary?&rdquo;.</p>
<p>After a few iterations to allow for more features, especially cross-user content we landed here:</p>
<p><img src=/images/database-design-marc-1.4.png alt></p>
<p>Reality eventually got the better of us and we decided to cut down the feature list to a more manageable size in line with our time table. We focussed on the single user experience with only the basic groundwork laid for cross-user content, simplified the user profile, and significantly simplified context handling.</p>
<p>This is what we arrived at for the initial release of Alexandria:</p>
<p><img src=/images/database-design-marc-1.10.png alt></p>
<p>As you can see, for the final design we stripped the connecting tables of their own unique ids, and made composite keys - the combinations of the foreign key columns - the primary keys. This would ensure that the connections are unique and a user cannot have, for example, two statuses for the same word.</p>
<p>Admittedly it should also have been done for the <code>words</code> table, because each word (ie. combination of letters) is unique in its language. But this occurred to us too late into the project and we stuck to the id as primary key for <code>words</code>.</p>
<p>It is for this small detail that our database does probably not full satisfy <strong>3NF</strong>, but it is close enough to achieve all the objectives of normalization.</p>
<h4 id=naming-things>Naming things</h4>
<p>A useful side effect of designing the database very early in the project was that we had to agree on the names of the entities that we were going to deal with in our code. Eg. what is a word, what is a phrase? (They are actually the same in the database but different for text parsing). Finding that common language was essential for all communication going forward.</p>
<h4 id=alexandrias-mvp-database-tables>Alexandria&rsquo;s MVP database tables</h4>
<h5 id=main-tables>Main tables</h5>
<table>
<thead>
<tr>
<th>table</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>users</td>
<td>The people using Alexandria. Each user can actively learn one language at a time and translate to one base language. If the language preferences change, previous progress (translations, word statuses) is kept.</td>
</tr>
<tr>
<td>admins</td>
<td>The people adminiteing Alexandria. That would be us for now.</td>
</tr>
<tr>
<td>languages</td>
<td>The languages that are supported by Alexandria. For the first release, it is a list of ten. What they have in common is their use of a latin-based alphabet (to avoid surprises with our text parser for now) and their being supported by the PostgreSQL text search. A flag representing the language is saved as a unicode character combination to be used in menus across the application.</td>
</tr>
<tr>
<td>texts</td>
<td>The key entity for learning. Texts are currently provided by users through forms, later through URLs and files. Texts default to being priovate which should particularly suit those who learn best by reading state secrets or erotic literature. Public texts, that can be used by every user to study, could be an option for a future release. The database already provides the necessary column.</td>
</tr>
<tr>
<td>words</td>
<td>Translatable entities. Usually single words like <em>cabbage</em>, but also compounds, or phrases, like <em>get up</em> or <em>l&rsquo;hôtel</em>. Each word must be unique within its language. It can have different meanings (translations) but in database terms, each combination of letters must occur only once per language.</td>
</tr>
<tr>
<td>translations</td>
<td>Translations of words can be provided or selected by the users, but they exist independently of the users who created them. The go from the language of the word in question to a target language associated with this specific translation. Translations could also also be automatically generated to seed the database with a language&rsquo;s most common words; another feature for a follow up version.</td>
</tr>
<tr>
<td>webdictionaries</td>
<td>Online resources in which the user can look up a word or phrase. They</td>
</tr>
</tbody>
</table>
<h5 id=connecting-tables>Connecting tables</h5>
<table>
<thead>
<tr>
<th>table</th>
<th>purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>users_words</td>
<td>Word statuses for a usr-word combination are &ldquo;learning&rdquo;, familiar&rdquo;, and &ldquo;learned&rdquo;.User dictionaries could be generated using this table.</td>
</tr>
<tr>
<td>users_translations</td>
<td>Every translated word orginates in a text, and the surrounding words from that text form the translation&rsquo;s context. Users have their own contexts for every translation. If the translation is not newly provided but simply selected from previous translations, the current context is saved and connected to selected the translation and user.</td>
</tr>
<tr>
<td>webdictionary_preference</td>
<td>Users can have one favourite dictionary per source language.</td>
</tr>
</tbody>
</table>
<h3 id=api-design>API Design</h3>
<p>In the design of the API that is queried by the React front end, we tried to follow <a href=https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm>REST</a> principles as well as possible within the constraints of our type of application and of the current state of development.</p>
<ul>
<li><strong>Client-Server</strong>: as mentioned previously, this separation came naturally with the decision to create a React-based single page application.</li>
<li><strong>Stateless</strong>: For security reasons and device inerchangeability, only the user id is stored with the client in a JSON Web token which is sent with every request. Additional information is always drawn from the user state which is kept in a Recoil atom. The request then includes the combined state information and sends it to the server.</li>
<li></li>
</ul>
<h4 id=resources-and-collections>Resources and collections</h4>
<ul>
<li><strong>Resources</strong> are the individual items (rows) of the main database tables (&ldquo;single noun&rdquo; name, coloured in the graph). Each resource has a unique (integer) id within its table.</li>
<li><strong>Collections</strong> are lists of resources, that can be filtered by criteria such as languages or user.</li>
</ul>
<h4 id=general-route-pattern-rules>General route pattern rules</h4>
<h5 id=basic-access>Basic access</h5>
<ul>
<li>The type of the resource that is queried is always the first part of the route.</li>
<li>This is the case for both individual resources and collections.</li>
<li>Individual resources are accessed by their id.</li>
<li>Data from other resources associated with the queried resource might be sent back as well, but querying those happens on the backend and is not exposed via the API.</li>
<li>Creation, updates and deletion of resources happens via the basic route (ie. without filters).</li>
</ul>
<h6 id=examples>Examples</h6>
<ul>
<li><code>GET /texts/</code> => a collection of all texts</li>
<li><code>GET /texts/38422</code> => the text with id <code>38422</code></li>
<li><code>POST /translations</code> => create a new translation</li>
<li><code>PUT /users</code> => update user data</li>
<li><code>DELETE /texts/38422</code>=> removes text with id <code>22533</code></li>
</ul>
<h5 id=filtering-collections>Filtering collections</h5>
<ul>
<li>If the second part of the route is not an id (ie. not an integer), we are looking for a filtered collection of that resource.</li>
<li>Filters are indicated by a keyword (in singular) and a unique identifier.</li>
<li>Filters can be chained.</li>
<li>Filtering for the logged-in user only requires the <code>user</code> keyword because the id is stored in the active session. The user keyword is always the last in the route.</li>
</ul>
<h6 id=examples-1>Examples</h6>
<ul>
<li><code>GET /translations/word/22533</code> => all translations (to all languages) for word with id <code>22533</code></li>
<li><code>GET /translations/language/de/word/22533</code> => all translations to German (unique identifier <code>de</code>) for word with id <code>22533</code></li>
<li><code>GET /words/text/38422/user</code> => all words in text <code>38422</code> that the user already has marked.</li>
<li><code>GET /texts/user</code> => all texts belonging to the current user</li>
<li><code>GET /texts/language/fr/user</code> => all texts in French (unique identifier <code>de</code>) belonging to the current user</li>
</ul>
</div>
</section>
<section class=page id=challenges>
<h1>
<a href=#challenges>Challenges and Solutions</a>
</h1>
<div class=content>
<p>What challenges we faced and how we solved them.</p>
<h3 id=parsing-the-text-for-words-and-phrases>Parsing the text for words and phrases</h3>
<h3 id=getting-the-most-out-of-postgresql>Getting the most out of PostgreSQL</h3>
<h3 id=creating-the-ui-for-selecting-phrases>Creating the UI for selecting phrases</h3>
<p>One of the most important features of our app is allowing users to select and save phrases along with its translation. This ended up being more challenging than expected due to the way our texts are displayed. Each word in a user text has its own state, and resides in its own span. When a user clicks on a word, it is added to the <code>currentWord</code> state, which then triggers a re-render of the translation input component, which contains the current word, existing translations, links to dictionaries and translations, as well as the option for the user to set their level of familiarity with the word.</p>
<p>Phrases are their own component, separate from words. They are also surrounded by spans which are highlighted based on the users level of familiarity with the phrase. So we needed a way to create phrases on the fly as users selected them. So when a user selects several words, their selection is added to the <code>userWords</code> object, which automatically highlights the new phrase.</p>
<p>This sounds relatively simple, but the challenges appeared depending on how the user selected the word. Consider, for example, the phrase &ldquo;for example&rdquo;. If the user started or ended their selection in the middle of a word, the <code>currentWord</code> might end up being displayed as &ldquo;or examp&rdquo; instead of &ldquo;for example&rdquo;.</p>
<p>Using the browser API <code>Selection</code>, we were able to get the <code>anchorNode</code> and <code>focusNode</code>, the nodes where the selection started and ended. With access to those nodes, we could extract the full words using the nodes <code>textContent</code> property, meaning it was trivial to replace the first and last words of the selection with the full words. This gives the user a much better experience as they can select phrases without having to be careful to always select full words.</p>
<p>The only problem with this approach was that if for some reason a user selected a phrase dragging the mouse from right to left, the first and last word would be reversed. We tried to solve this by saving the X location of the mouse pointer <code>onMouseDown</code> and comparing it to the end X location <code>onMouseUp</code> to see if the selection was done backwards or not. But when a selection was done across multiple lines and the start point was further left than the end point, it didn&rsquo;t work.</p>
<p>As we had access to the context (the phrase the selection was from), in the end we were able to simply test if the phrase appeared in the context, and if not, switch the first and last words, thus greatly simplifying the selection logic.</p>
</div>
</section>
<section class=page id=future>
<h1>
<a href=#future>Current State and Future Plans</a>
</h1>
<div class=content>
<p>Where we are now, and where we are going</p>
<h3 id=mvp>MVP</h3>
<h3 id=moving-forward>Moving Forward</h3>
</div>
</section>
<section class=page id=team>
<h1>
<a href=#team>Team</a>
</h1>
<div class=content>
<h3 id=dana-chen>Dana Chen</h3>
<h3 id=eamon-ocallaghan>Eamon O&rsquo;Callaghan</h3>
<h3 id=marc-hermann>Marc Hermann</h3>
</div>
</section>
<section class=page id=references>
<h1>
<a href=#references>References</a>
</h1>
<div class=content>
<ol>
<li>
<p><a href=https://www.researchgate.net/publication/349255011_Explorations_in_Language_Acquisition_and_Use>https://www.researchgate.net/publication/349255011_Explorations_in_Language_Acquisition_and_Use</a></p>
</li>
<li>
<p>Edgar F. Codd (1972): <a href=https://forum.thethirdmanifesto.com/wp-content/uploads/asgarosforum/987737/00-efc-further-normalization.pdf>Further Normalization of the Data Base Relational Model</a></p>
</li>
</ol>
</div>
</section>
</div>
</body>
</html>